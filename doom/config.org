#+TITLE: Doom Emacs Configuration
#+PROPERTY: header-args :tangle config.el

* Introduction

My Doom Emacs configuration.

Note to self:
- Re-tangle with =C-c C-v t=.
- Local refresh with =C-c C-c= on org title.

** Update Repository

You can ignore this I just have it here so I can quickly update my dotfiles repository.

#+begin_src shell :eval yes :tangle no :results none
rm -r ~/Desktop/dotfiles/doom/*
cp -r ~/.config/doom/* ~/Desktop/dotfiles/doom
#+end_src

* Custom
** Functions
These are some custom utility functions that I've created because I find use for them.

*** jecs/toggle-quote-lines

This function wraps a selected region with double quote ="= symbols.

#+begin_src emacs-lisp :results none
(defun jecs/toggle-quote-lines (beg end)
  "Toggle wrapping all items in region with double quotes."
  (interactive (list (mark) (point)))
  (unless (region-active-p)
    (user-error "No region to wrap"))
  (let ((deactivate-mark nil)
        (replacement (string-join
                      (mapcar (lambda (item)
                                (if (string-match-p "^\".*\"$" item)
                                    (string-trim item "\"" "\"")
                                  (format "\"%s\"" item)))
                              (split-string (buffer-substring beg end) "\n"))
                      "\n")))
    (delete-region beg end)
    (insert replacement)))
#+end_src

*** Toggle Mode

This function toggles the current major mode by switching to fundamental mode then back to
whatever mode was previously active.

#+begin_src emacs-lisp :tangle yes
(defun jecs/toggle-major-mode ()
  (interactive)
  (let ((old-major-mode major-mode))
    (fundamental-mode)
    (funcall old-major-mode)))
#+end_src

#+RESULTS:
: jecs/toggle-major-mode

*** jecs/stare

This function opens one of my preselected images and maximizes it in a new buffer.

Don't ask me why I'm weird.

#+begin_src emacs-lisp :results none
(defun jecs/stare ()
  "Opens random image from predefined list."
  (interactive)
  (let ((image-list '("~/Pictures/o_o/Gregory.png"
                      "~/Pictures/o_o/hamsterStare.png"
                      "~/Pictures/o_o/monkaStare.png"
                      "~/Pictures/o_o/Stare.png"
                      "~/Pictures/o_o/crunchy-cat-luna.png"
                      "~/Pictures/o_o/knight.png"
                      "~/Pictures/o_o/mikeStare.png")))
    (ffap (nth (random (length image-list)) image-list)))
  (image-transform-fit-to-window))
#+end_src

*** jecs/listening

This function opens one of my preselected gifs, maximizes it, and enables animation, in a new buffer.

Don't ask me why I'm weird.

#+begin_src emacs-lisp :results none
(defun jecs/listening (arg)
  "Opens listening gif. When ARG is non-nil, will open not-listening gif."
  (interactive "P")
  (ffap
   (if arg
       "~/Pictures/library/not-listening.gif"
     "~/Pictures/library/listening.gif"))
  (image-transform-fit-to-window)
  (image-toggle-animation)
  (message "%s" arg))
#+end_src

*** jecs/sp-kill-entire-sexp

#+begin_src emacs-lisp :results none
(defun jecs/sp-kill-sexp-region ()
  "Kill the text between sp-beginning-of-sexp and sp-end-of-sexp."
  (interactive)
  (save-excursion
    (let ((beg (progn (sp-beginning-of-sexp) (point)))
          (end (progn (sp-end-of-sexp) (point))))
      (kill-region beg end))))
#+end_src

** COMMENT Keybinds

These are some misc keybinds that I use.

#+begin_src emacs-lisp :results none
;; custom keybinds
(map! :leader
      (:prefix-map ("j" . "jecs")
                   :desc "Stare" "S" #'jecs/stare
                   :desc "Listening" "l" #'jecs/listening
                   :desc "Open Phone" "p" #'scrcpy-open
                   :desc "Toggle Major Mode" "t" #'jecs/toggle-major-mode))

;; global keybinds
(map! :g "C-x L" #'count-lines-page
      :g "C-x l" #'duplicate-dwim
      :g "C-x C-c" nil
      :g "s-k" #'kill-buffer-and-window
      :g "C-M-z" #'sp-backward-up-sexp
      :g "C-M-S-k" #'jecs/sp-kill-sexp-region)

(if (display-graphic-p)
    (map! :g "C-z" nil))

(map! :desc "Repeat" :g "C-." #'repeat)

(map! :leader
      ;; misc
      :desc "New Emacs Instance" "o e" #'restart-emacs-start-new-emacs
      :desc "Open Calculator"    "o c" #'calc
      :desc "Open Calendar"      "o k" #'calendar
      :desc "Open Scratch"       "o x" #'scratch-buffer

      ;; terminals
      :desc "Open large vterm (here)" "o t" #'+vterm/here
      :desc "Popup vterm"             "t t" #'+vterm/toggle)
#+end_src

** General

#+begin_src emacs-lisp :results none
;; scroll the compilation buffer
(setq compilation-scroll-output t)
(setq compilation-scroll-output 'first-error)

(setq user-full-name "Joshua Carrasco"
      user-mail-address "mail@joshuacarrasco.com")

(setq-default delete-by-moving-to-trash t)
(setq display-line-numbers-type t)
(setq org-directory "~/org/")

;; dont ask me
(setq confirm-kill-emacs nil
      confirm-kill-processes nil)

(setq-default tab-width 2)
(setq tab-width 2)
(setq show-paren-delay 0)
(set-fringe-mode 0)

;; so cross program copy paste will add to kill ring
(setq save-interprogram-paste-before-kill t)
(setq read-process-output-max (* 1024 1024))

(setq default-frame-alist
      (append
       '((top . -1) (left . 0)
         (width . 220) (height . 70)
         (alpha-background . 98)
         (name . "emacs")
         (font . "Iosevka-18"))
       default-frame-alist))

(add-to-list 'load-path (expand-file-name "lisp" doom-user-dir))
#+end_src

** Doom

My doom dashboard configuration.

*** Set banner

A pool of ASCII arts that will be randomly chosen from for the dashboard.

#+name: tangled/banners
#+begin_src elisp :tangle no :results none
(list (list (f-read-text "./asciis/aqua.txt"))
      (list (f-read-text "./asciis/maid.txt"))
      (list (f-read-text "./asciis/rias.txt"))
      (list (f-read-text "./asciis/osaka.txt")))
#+end_src

#+begin_src emacs-lisp :tangle yes :var banners=tangled/banners :results none
(defvar jecs/banners banners)
#+end_src

Set doom dashboard by picking a random ascii.

#+begin_src emacs-lisp :results none 
(setq +doom-dashboard-ascii-banner-fn
      (lambda ()
        (let* ((banner (nth (random (length jecs/banners)) jecs/banners))
               (longest-line (apply #'max (mapcar #'length banner))))
          (put-text-property
           (point)
           (dolist (line banner (point))
             (insert (+doom-dashboard--center
                      +doom-dashboard--width
                      (concat line (make-string (max 0 (- longest-line (length line))) 32)))
                     "\n"))
           'face 'doom-dashboard-banner))))
#+end_src

*** Benchmark

Override default =doom-display-benchmark-h= function with different formatting.

#+begin_src emacs-lisp :results none
(defun doom-display-benchmark-h (&optional return-p)
  "Display a benchmark including number of packages and modules loaded.

If RETURN-P, return the message as a string instead of displaying it."
  (funcall (if return-p #'format #'message)
           "Loaded %d packages in %.03fs"
           (- (length load-path) (length (get 'load-path 'initial-value)))
           doom-init-time))
#+end_src

*** Dashboard functions

Remove the footer widget from the dashboard.

#+begin_src emacs-lisp :results none
(defun jecs/doom-dashboard-maybe-banner ()
  "Show banner only when frame is large enough."
  (when (and (>= (frame-width) 91)
             (>= (frame-height) 41))
    (doom-dashboard-widget-banner)))

(setq +doom-dashboard-functions
      '(jecs/doom-dashboard-maybe-banner
        doom-dashboard-widget-shortmenu
        doom-dashboard-widget-loaded))
#+end_src

*** Sections

Remove some sections from the dashboard.

#+begin_src emacs-lisp :results none
(setq +doom-dashboard-menu-sections (cl-subseq +doom-dashboard-menu-sections 0 2))
#+end_src

*** Other

Other small changes.

#+begin_src emacs-lisp :results none
;; disable hl line on dashboard
(add-hook! '+doom-dashboard-functions
  (setq hl-line-mode nil)
  (hide-mode-line-mode 1))

;; override function to remove newlines at start
(defun doom-dashboard-widget-loaded ()
  "Overrides doom dashboard loaded function."
  (when doom-init-time
    (insert
     ""
     (propertize
      (+doom-dashboard--center
       +doom-dashboard--width
       (doom-display-benchmark-h 'return))
      'face 'doom-dashboard-loaded)
     "\n")))

;; TODO: fix this
;; (after! doom-modeline
;;   (setq doom-modeline-height 0
;;         doom-modeline-buffer-modification-icon nil
;;         doom-modeline-modal nil
;;         doom-modeline-icon nil
;;         doom-modeline-check-simple-format t))

(unless (display-graphic-p)
  (after! doom-ui
    (setq frame-title-format '("%b")
          icon-title-format frame-title-format)))
#+end_src

* Theme

Set theme and customize faces on some themes that I use.

#+begin_src emacs-lisp :tangle no
(package! darktooth-theme)
#+end_src

#+begin_src emacs-lisp :eval no
;; (setq doom-theme 'darktooth)
(setq doom-theme 'modus-vivendi)
#+end_src

** Darktooth Customizations

The [[https://github.com/emacsfodder/emacs-theme-darktooth][darktooth theme]] is my favourite theme, but I had to make some customizations for a couple things.

#+begin_src emacs-lisp :eval no :tangle no
(custom-theme-set-faces! 'darktooth
  ;; all colours come from darktooh theme unless specified

  ;; so that (text-scale-adjust) scales properly
  '(line-number :inherit default :foreground "#7C6F64" "#767676")
  ;; same colour for current line
  ;; '(line-number-current-line :inherit default :foreground "#7C6F64" "#767676")
  ;; slightly different colour for current line 
  '(line-number-current-line :inherit default :foreground "#A89984" "#767676")

  ;; tab bar
  '(tab-bar-tab :background "#3a3a3a" "#3a3a3a")
  '(tab-bar-tab-inactive :background "#1c1c1c" "#1c1c1c")
  '(tab-bar :background "#1c1c1c" "#1c1c1c")

  ;; org mode
  '(org-block-begin-line :inherit org-block :extend t :foreground "#928374" "#8a8a8a")
  '(org-block-end-line :inherit org-block :extend t :foreground "#928374" "#8a8a8a")
  '(org-block :background "#232323" "#262626" :extend t)

  ;; lsp
  ;; '(lsp-face-highlight-read :inherit 'highlight :underline nil :bold t)

  ;; diredfl
  ;; '(diredfl-symlink nil)
  
  ;; modeline icons not bold
  '(success :foreground "#B8BB26" "#73AF00" :bold nil)
  '(error :foreground "#FB4933" "#d75f5f" :bold nil)
  '(warning :foreground "#FABD2F" "#ffaf00" :bold nil)

  '(vterm-color-red :inherit term-color-red :background "#ff9090")
  '(vterm-color-blue :inherit term-color-blue :background "#7cc3f3")
  '(vterm-color-cyan :inherit term-color-cyan :background "#74e2ff")
  '(vterm-color-black :inherit term-color-black :background "#54595e")
  '(vterm-color-green :inherit term-color-green :background "#b1ce8b")
  '(vterm-color-white :inherit term-color-white :background "#e7e7e7")
  '(vterm-color-yellow :inherit term-color-yellow :background "#f0ce9c")
  '(vterm-color-magenta :inherit term-color-magenta :background "#d499e5")

  '(mode-line-highlight :foreground "#fffabc" :bold nil))
#+end_src

** Modus Vivendi Customizations

#+begin_src emacs-lisp :results output
(custom-theme-set-faces! 'modus-vivendi
  ;; Use the buffer background for the left margin
  '(line-number
    :inherit default
    :foreground "#6E6E6E" "#767676"
    :background nil)
  '(line-number-current-line
    :inherit default
    :foreground "#A8A8A8" "#9E9E9E"
    :background nil
    :weight bold)
  '(hl-line :background "#202020" "#202020" :extend t) ; highlighted line colour
  
  ;; org mode blocks
  '(org-block            :background "#0D0D0D" "#0d0d0d" :extend t)
  '(org-block-begin-line :inherit org-block :foreground "#6E6E6E")
  '(org-block-end-line   :inherit org-block :foreground "#6E6E6E")
  '(org-indent :inherit (org-hide))

  ;; mode line no outline
  '(mode-line
    :background "#3C3C3C" :foreground "#DADADA"
    :box nil :overline nil :underline nil)
  '(mode-line-inactive :background "#3C3C3C" :foreground "#8A8A8A"
    :box nil :overline nil :underline nil)
  '(mode-line-highlight :foreground "#ffffff" :background "#45605e" :box nil)

  ;; other
  '(fringe :background unspecified)
  '(region :background "#2E364A" "#2E364A" :extend t)
  '(aw-leading-char-face
    :inherit bold
    :foreground "#FF5555"   ;; pure red: "#FF0000", darker: "#CC3333"
    :background unspecified
    :height 1.0))
#+end_src

* Configure Packages
** benchmark-init

A benchmark profiler for debugging long Emacs startup times.

Enable profiler when emacs is run with with src_bash{emacs --debug-init}

#+begin_src emacs-lisp :tangle packages.el
(package! benchmark-init)
#+end_src

#+begin_src emacs-lisp :tangle yes
(when init-file-debug
  (require 'benchmark-init)
  (add-hook 'doom-first-input-hook #'benchmark-init/deactivate))
#+end_src

** Dired

#+begin_src emacs-lisp :tangle yes
(use-package! diredfl
  :defer t
  :config
  (setq dired-listing-switches "-ahHl -v --group-directories-first -H")
  (setq dired-free-space nil))
#+end_src

** Dirvish

#+begin_src emacs-lisp :tangle no :eval no
(use-package! dirvish
  :defer t
  :init
  (map! "C-x C-j" #'dirvish)
  :config
  (setq dirvish-default-layout '(0 0.4 1))
  (setq dirvish-attributes '(vc-state nerd-icons file-time file-size))
  (setq dirvish-time-format-string "%b %e %H:%M"))
#+end_src

** Tree Sitter

#+begin_src emacs-lisp :tangle yes :eval no
;; (use-package! tree-sitter
;;   :hook
;;   ((prog-mode . global-tree-sitter-mode)
;;    (tree-sitter-after-on . tree-sitter-hl-mode)))

;; (map!
;;  :after tree-sitter
;;  :leader
;;  :desc "Tree Sitter Highlight" :g "t h" #'tree-sitter-hl-mode)
#+end_src

** Treemacs

#+begin_src emacs-lisp :tangle no
(after! treemacs
  (treemacs-follow-mode 1))

(map! :leader :desc "Select Treemacs" :g "TAB" #'treemacs-select-window)
(map! :leader :desc "Open Project Sidebar" :g "o p" #'treemacs)
#+end_src

** Company

Company is a completion engine. I've been using corfu instead though.

#+begin_src emacs-lisp :tangle no
(after! company
  (setq company-minimum-prefix-length 1))
#+end_src

** Anzu

#+begin_src emacs-lisp :tangle yes
(use-package! anzu
  :defer 5
  :config
  (global-anzu-mode t))
#+end_src

** Gptel

Gptel is a tool to interact with large language models in emacs.

#+begin_src emacs-lisp :results none
(use-package! gptel
  :defer t
  :bind
  :config
  (add-hook 'gptel-post-stream-hook 'gptel-auto-scroll)
  (setq gptel-default-mode 'org-mode)
  (setq gptel-model 'gpt-5.1))

;; (setq gptel-model "llama3:latest"
;;         gptel-backend (gptel-make-ollama "Ollama"
;;                         :host "localhost:11434"
;;                         :stream t
;;                         :models '("llama3:latest")))
#+end_src

** Corfu

Corfu is an in buffer completion engine.

#+begin_src emacs-lisp :tangle yes
(after! corfu
  ;; (unless (display-graphic-p)
  ;;   (corfu-terminal-mode +1))
  (map! :map corfu-map
        "TAB" #'corfu-insert
        "<tab>" #'corfu-insert))

(after! corfu-auto
  (setq corfu-auto-delay 0.08
        corfu-auto-prefix 2))
#+end_src

** PlatformIO

[[https://github.com/ZachMassia/PlatformIO-Mode][PlatformIO]] is allows you to interact with PlatformIO Core CLI from emacs.

#+begin_src emacs-lisp :tangle no
(package! platformio-mode)
#+end_src

#+begin_src emacs-lisp :results none :tangle no
(use-package! platformio-mode
  :custom
  (platformio-mode-keymap-prefix (kbd "C-c l p"))
  :init
  ;; you may be required to make a .projectile file in project root.
  (add-hook 'c-mode-hook (lambda ()
                           (lsp-deferred)
                           (platformio-conditionally-enable)))
  (add-hook 'c++-mode-hook (lambda ()
                             (lsp-deferred)
                             (platformio-conditionally-enable)))

  :config
  (which-key-add-keymap-based-replacements platformio-mode-map
   "C-c l p" '("PlatformIO" . platformio-command-map)
   "C-c l p b" '("Build Project" . platformio-build)
   "C-c l p c" '("Clean Compile Objects" . platformio-clean)
   "C-c l p u" '("Build and Upload" . platformio-upload)
   "C-c l p p" '("Programmer Upload" . platformio-programmer-upload)
   "C-c l p s" '("SPIFFS Upload" . platformio-spiffs-upload)
   "C-c l p d" '("Update" . platformio-update)
   "C-c l p m" '("Device Monitor" . platformio-device-monitor)
   "C-c l p l" '("List Boards" . platformio-boards)
   "C-c l p i" '("Update Workspace" . platformio-init-update-workspace)))
#+end_src

** TRAMP

Documentation at: https://coder.com/docs/v2/latest/ides/emacs-tramp

#+begin_src emacs-lisp :results none :tangle no
(after! tramp
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))

(setq tramp-verbose 10)
(setq tramp-default-method "plink")
(setq tramp-remote-path '("/mnt/c/Program Files/PuTTY"))
#+end_src

** scrcpy

scrcpy is a work in progress package that I'm working on to interact with the scrcpy command line utility from emacs.

#+begin_src emacs-lisp :results none :tangle no
(load! "scrcpy.el")
#+end_src

** Org

#+begin_src emacs-lisp :results none
(add-hook 'org-mode-hook 'yas-minor-mode-on)
#+end_src

** Org Hugo

#+begin_src emacs-lisp :results none
(after! ox-hugo
  :defer t
  (setq org-hugo-base-dir
        (concat org-directory "hugo")))
#+end_src

** Org Roam

#+begin_src emacs-lisp :results none
(use-package! org-roam
  :defer t
  :custom
  (org-roam-capture-templates
   '(("d" "default" plain "%?" :target
      (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags:\n")
      :unnarrowed t)
     ("e" "emacs" plain "%?" :target
      (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: emacs\n")
      :unnarrowed t)
     ("m" "math" plain "#+STARTUP: latexpreview\n%?" :target
      (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: math\n")
      :unnarrowed t)
     ("p" "programming" plain "%?" :target
      (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: programming\n")
      :unnarrowed t)
     ("l" "legal" plain "#+STARTUP: latexpreview\n%?" :target
      (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: legal\n")
      :unnarrowed t)
     ("w" "work" plain "%?" :target
      (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: work\n")
      :unnarrowed t)
     ("s" "system" plain "#+STARTUP: latexpreview\n%?" :target
      (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: system\n")
      :unnarrowed t)
     ("c" "cloud" plain "%?" :target
      (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: cloud\n")
      :unnarrowed t))))
#+end_src

** Org Roam UI

A fancy UI for org roam. https://github.com/org-roam/org-roam-ui

#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-ui)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))

(map!
 :after org-roam-ui
 :desc "Open Web UI" :leader "n r w" #'org-roam-ui-open)
#+end_src

** Consult / Vertico

#+begin_src emacs-lisp :results none
(map! :g "C-x b" #'consult-buffer
      
      :when (modulep! :editor evil)
      :after consult
      :leader
      :desc "Switch buffer" "b b" #'consult-buffer
      
      :when (modulep! :editor evil)
      :after vertico
      :leader
      :desc "Switch workspace buffer" "b B" #'+vertico/switch-workspace-buffer)
#+end_src

** God Mode

#+begin_src emacs-lisp :results none :tangle no
(after! god-mode
  (god-mode-all -1)
  (map! :desc "Toggle God Mode" :g "M-m" #'god-local-mode)
  (define-key god-local-mode-map (kbd ".") #'repeat)
  (define-key god-local-mode-map (kbd "C-x C-1") #'delete-other-windows)
  (define-key god-local-mode-map (kbd "C-x C-2") #'split-window-below)
  (define-key god-local-mode-map (kbd "C-x C-3") #'split-window-right)
  (define-key god-local-mode-map (kbd "C-x C-0") #'delete-window)

  (after! ace-window
    (define-key god-local-mode-map (kbd "C-x C-o") #'ace-window)))
#+end_src

** Tab Bar

#+begin_src emacs-lisp :results none :tangle no
(map! :after tab-bar :desc "Toggle Tab Bar Mode" :g "C-x t C-0" #'tab-bar-mode)
#+end_src

** WS Butler

White Space butler

#+begin_src emacs-lisp :tangle yes :results none
(use-package! ws-butler
  :config
  (add-to-list 'ws-butler-global-exempt-modes 'text-mode))
#+end_src

** mu4e

#+begin_src emacs-lisp :tangle no
(use-package! mu4e
  :defer 60
  :config
  (set-email-account! "info@joshuacarrasco.com"
                      '((mu4e-sent-folder       . "/info/Sent Mail")
                        (mu4e-drafts-folder     . "/info/Drafts")
                        (mu4e-trash-folder      . "/info/Trash")
                        (mu4e-refile-folder     . "/info/All Mail")
                        (smtpmail-smtp-user     . "info@joshuacarrasco.com")
                        (mu4e-compose-signature . "---\nRegards\nJoshua"))
                      t)
  (set-email-account! "mail@joshuacarrasco.com"
                      '((mu4e-sent-folder       . "/mail/Sent Mail")
                        (mu4e-drafts-folder     . "/mail/Drafts")
                        (mu4e-trash-folder      . "/mail/Trash")
                        (mu4e-refile-folder     . "/mail/All Mail")
                        (smtpmail-smtp-user     . "mail@joshuacarrasco.com")
                        (mu4e-compose-signature . "---\nRegards\nJoshua"))
                      t)
  
  (setq +mu4e-gmail-accounts '(("mail@joshuacarrasco.com" . "/mail")
                               ("info@joshuacarrasco.com" . "/info")))
  (setq mu4e-update-interval 60)
  (setq smtpmail-smtp-server "smtp.gmail.com")
  (setq mu4e-modeline-show-global nil))
#+end_src

** Avy

Go to any where on screen within your buffer.

#+begin_src emacs-lisp :tangle no
(use-package! avy
  :defer 30
  :config
  (map!
   :desc "Avy Goto Character" :leader "s c" #'avy-goto-char-2))
#+end_src

** eldoc-box

Childframe package for eldoc.

#+begin_src emacs-lisp :tangle no
(package! eldoc-box)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! eldoc-box
  :config
   (custom-set-faces!
    '(eldoc-box-border :background "#3f3f3f"))
   (add-hook 'eglot-managed-mode-hook #'eldoc-box-hover-mode t))

(map! :after (eldoc eldoc-box)
      :desc "Eldoc Help at point" :g "C-M-y" #'eldoc-box-help-at-point)
#+end_src

** pass

#+begin_src emacs-lisp :tangle no
(package! pass)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! pass
  :defer t
  :config
  (setf epa-pinentry-mode 'loopback))
#+end_src

** Rotate Text

#+begin_src emacs-lisp :tangle yes
(defun jecs/rotate-text (prefix)
  "Rotate text in region using `rotate-text' at each word boundary.
If there is no region then call `rotate-text' normally."
  (interactive "p")
  (let ((numeric-prefix (if (null prefix) 1
                          (prefix-numeric-value prefix))))
    (if (not (use-region-p))
        (rotate-text numeric-prefix)
      (let ((case-fold-search 0)
            (start (region-beginning))
            (end (region-end)))
        (save-excursion
          (while (and (goto-char end)
                      (setq end (re-search-backward "\\b\\w" start t)))
            (condition-case nil
                (rotate-text numeric-prefix)
              (error nil))))))))

(defun jecs/rotate-text-backward (prefix)
  "Same as `jecs/rotate-text' but backwards."
  (interactive "p")
  (let ((numeric-prefix (if (null prefix) 1
                          (prefix-numeric-value prefix))))
    (jecs/rotate-text (- numeric-prefix))))

(use-package! rotate-text
  :bind
  ("C-c ]" . jecs/rotate-text)
  ("C-c [" . jecs/rotate-text-backward)
  :config
  (add-to-list 'rotate-text-words '("none" "some"))
  (add-to-list 'rotate-text-words '("start" "end"))
  (add-to-list 'rotate-text-words '("buy" "sell"))
  (add-to-list 'rotate-text-words '("before" "after"))
  (add-to-list 'rotate-text-words '("min" "max"))
  (add-to-list 'rotate-text-words '("win" "lose"))
  (add-to-list 'rotate-text-words '("high" "low")))
#+end_src

** Verb

[[https://github.com/federicotdn/verb][Verb]] is an HTTP client for emacs.

#+begin_src emacs-lisp :tangle packages.el
(package! verb)
#+end_src

#+begin_src emacs-lisp :tangle yes
(after! verb
  (setq! verb-trim-body-end "[ \t\n\r]+"))

(map! :after org
      :desc "Verb Prefix"
      :map org-mode-map
      "C-c C-r" verb-command-map)
#+end_src

** Slack

Slack [[https://github.com/emacs-slack/emacs-slack][client for emacs]].

Note to self:

If your token expires run =M-x slack-refresh-token=

#+begin_src emacs-lisp :results output :tangle packages.el
(package! slack)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! slack
  :commands (slack-start slack-stop slack-select-rooms)
  :init
  (map! :leader :desc "Open slack rooms" "o s" #'slack-select-rooms)

  :config
  ;; first launch setup
  (defun +slack--ensure-connected ()
    (unless (cl-loop for team being the hash-values of slack-teams-by-token
                     thereis (slack-team-connectedp team))
      (slack-start)))
  (advice-add #'slack-select-rooms :before #'+slack--ensure-connected)

  ;; slack connections
  (let* ((chan-secret (auth-source-pick-first-password
                       :host "slack"
                       :user "channels"))
         (my/slack-channels (and chan-secret (split-string chan-secret))))
    (slack-register-team
     :name "work" :default t
     :token  (auth-source-pick-first-password
              :host "slack" :user "token")
     :cookie (auth-source-pick-first-password
              :host "slack" :user "cookie")
     :subscribed-channels my/slack-channels
     :full-and-display-names t))

  ;; other
  (setq slack-prefer-current-team t)
  (map! :prefix ("C-z" . "Slack")
        :desc "Start slack" "S" #'slack-start
        :desc "Open a chat"  "c" #'slack-select-rooms
        :desc "Select unread rooms"  "u" #'slack-select-unread-rooms
        :desc "Display a user's profile"  "U" #'slack-user-select
        :desc "Search all channels"  "s" #'slack-search-from-messages
        :desc "Jump to app"  "j" #'slack-jump-to-app
        :desc "Edit message"  "e" #'slack-message-edit
        :desc "Delete message"  "k" #'slack-message-delete
        :desc "Reply in thread"  "r" #'slack-thread-show-or-create
        :desc "Refresh"  "g" #'slack-message-redisplay
        :desc "Refresh Quick"  "G" #'slack-conversations-list-update-quick
        :desc "Set read mark"  "m" #'slack-message-update-mark
        :desc "Quit slack"  "K" #'slack-stop)
  (map! :map slack-mode-map
        "@"      #'slack-message-embed-mention
        "#"      #'slack-message-embed-channel)
  (map! :map slack-thread-message-buffer-mode-map
        "@"      #'slack-message-embed-mention
        "#"      #'slack-message-embed-channel
        "C-c '"  #'slack-message-write-another-buffer)
  (map! :map slack-message-buffer-mode-map
        "C-c '"  #'slack-message-write-another-buffer)
  (map! :map slack-message-compose-buffer-mode-map
        "C-c '"  #'slack-message-send-from-buffer))

(use-package! alert
  :commands (alert)
  :init
  (setq alert-default-style 'notifier))
#+end_src

** Evil

Evil mode customizations.

#+begin_src emacs-lisp :results no :tangle yes
(after! evil
  (setq evil-insert-state-message nil
        evil-visual-state-message nil
        evil-replace-state-message nil))
#+end_src

** vterm

#+begin_src emacs-lisp :results no :tangle yes
(after! vterm
  (setq vterm-timer-delay nil))
#+end_src

* Programming

Configurations for programming languages.

** LSP Mode

General LSP mode configurations.

#+begin_src emacs-lisp :results none :tangle yes
(use-package lsp-mode
  :defer t
  :config
  (setq lsp-idle-delay 0.03)
  (setq lsp-file-watch-threshold 10000)
  (setq lsp-modeline-diagnostics-enable nil)
  (setq lsp-modeline-code-actions-segments nil))

(after! lsp-ui-sideline
  (setq lsp-ui-sideline-diagnostic-max-line-length 300))

(after! lsp-ui-doc
  (setq lsp-ui-doc-max-width 300))
#+end_src

** Emacs LSP Booster

[[https://github.com/blahgeek/emacs-lsp-booster][emacs-lsp-booster]] improves the performenace of lsp-mode by wrapping the lsp with an executable that translates json messages to elisp bytecode so Emacs doesn't have to.

If =lsp-use-plists= isn't non-nil then =export LSP_USE_PLISTS=true= and run =doom sync --rebuild=.

No longer using since added by doom lsp module.

#+begin_src emacs-lisp :tangle no
(defun lsp-booster--advice-json-parse (old-fn &rest args)
  "Try to parse bytecode instead of json."
  (or
   (when (equal (following-char) ?#)
     (let ((bytecode (read (current-buffer))))
       (when (byte-code-function-p bytecode)
         (funcall bytecode))))
   (apply old-fn args)))

(advice-add (if (progn (require 'json)
                       (fboundp 'json-parse-buffer))
                'json-parse-buffer
              'json-read)
            :around
            #'lsp-booster--advice-json-parse)

(defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
  "Prepend emacs-lsp-booster command to lsp CMD."
  (let ((orig-result (funcall old-fn cmd test?)))
    (if (and (not test?)                             ;; for check lsp-server-present?
             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
             lsp-use-plists
             (not (functionp 'json-rpc-connection))  ;; native json-rpc
             (executable-find "emacs-lsp-booster"))
        (progn
          (message "Using emacs-lsp-booster for %s!" orig-result)
          (cons "emacs-lsp-booster" orig-result))
      orig-result)))
(advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src

** eglot

Emacs polyglot LSP

#+begin_src emacs-lisp :results none :tangle no
(after! eglot
  (setq eglot-send-changes-idle-time 0.0)
  (setq eldoc-idle-delay 0.0)
  (setq! eglot-code-action-indications '()) ; disable actions
  (setq eglot-ignored-server-capabilities '(:inlayHintProvider))
  (custom-set-faces!
    '(eglot-highlight-symbol-face
      :inherit highlight)))
#+end_src

** debug dape/dap

#+begin_src emacs-lisp :results none
(with-eval-after-load 'dap-mode
  (setq dap-default-terminal-kind "integrated") ;; Make sure that terminal programs open a term for I/O in an Emacs buffer
  (dap-auto-configure-mode +1))

#+end_src

** Python

#+begin_src emacs-lisp :results none
(after! lsp-mode
  (setq lsp-pyright-multi-root nil))
#+end_src

** WGSL

The shader language for WebGPU

#+begin_src emacs-lisp :tangle no
(package! wgsl-mode)
#+end_src

#+begin_src emacs-lisp :results none :tangle no
(with-eval-after-load 'lsp-mode
  (add-to-list 'lsp-language-id-configuration
               '(wgsl-mode . "wgsl"))

  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection "wgsl_analyzer")
                    :major-modes '(wgsl-mode)
                    :server-id 'wgsl-ls)))
#+end_src

** Rust

#+begin_src emacs-lisp :results none
;; (after! rustic
;;   (setq lsp-inlay-hint-enable t))

;; (setq dape-configurations
;;       (list
;;        (list :name "Rust LLDB"
;;              :type "lldb"
;;              :program "${workspaceFolder}/target/debug/<your-binary>"
;;              :request "launch"
;;              :cwd "${workspaceFolder}"
;;              :stopOnEntry t)))

;; (after! dap-mode
;;   (dap-ui-mode)
;;   (dap-ui-controls-mode 1)

;;   ;; (require 'dap-lldb)
;;   (require 'dap-cpptools)
;;   ;; (require 'dap-gdb-lldb)
;;   ;; installs .extension/vscode
;;   ;; (dap-gdb-lldb-setup)
;;   (dap-cpptools-setup)
;;   (dap-register-debug-template "Rust::CppTools Run Configuration"
;;                                (list :type "cppdbg"
;;                                      :request "launch"
;;                                      :name "Rust::Run"
;;                                      :MIMode "gdb"
;;                                      :miDebuggerPath "rust-gdb"
;;                                      :environment []
;;                                      :program "${workspaceFolder}/target/debug/image2ascii"
;;                                      :cwd "${workspaceFolder}"
;;                                      :console "external"
;;                                      :dap-compilation "cargo build"
;;                                      :dap-compilation-dir "${workspaceFolder}")))
#+end_src

** C/C++

#+begin_src emacs-lisp :results none
(setq c-basic-offset 4)

(after! (tramp lsp-mode)
  (lsp-register-client ;; c/c++ remote LSP
   (make-lsp-client :new-connection (lsp-tramp-connection "clangd")
                    :major-modes '(c-mode c++-mode)
                    :remote? t
                    :server-id 'clangd-remote)))

(after! lsp-clangd
  (setq lsp-clients-clangd-args
        '("-j=3"
          "--background-index"
          "--clang-tidy"
          "--completion-style=detailed"
          "--header-insertion=never"
          "--header-insertion-decorators=0"))
  (set-lsp-priority! 'clangd 2))
#+end_src

** C# / C Sharp

#+begin_src emacs-lisp :results none
(after! (tramp lsp-mode)
  (lsp-register-client ;; c-sharp remote LSP
   (make-lsp-client :new-connection (lsp-tramp-connection "csharp-ls")
                    :major-modes '(csharp-mode)
                    :remote? t
                    :server-id 'csharp-ls-remote)))

(after! csharp-mode
  (set-formatter! 'csharpier '("dotnet-csharpier" "--write-stdout") :modes '(csharp-mode)))

(after! lsp-mode
  :config
  (setq lsp-csharp-omnisharp-enable-decompilation-support t))
#+end_src

** JavaScript / TypeScript

#+begin_src emacs-lisp :results none
(after! (tramp lsp-mode)
  (lsp-register-client ;; javascript remote LSP
   (make-lsp-client :new-connection (lsp-tramp-connection "typescript-language-server --stdio")
                    :major-modes '(rjsx-mode js2-mode typescript-mode)
                    :remote? t
                    :server-id 'ts-ls-remote)))

(after! typescript-mode
  (setq ts-indent-level 4))
#+end_src

** ReasonML

ReasonML is an /alternative syntax/ to OCaml for the web. 
Not using this anymore, so leaving it untangled.

#+begin_src emacs-lisp :tangle no
(package! reason-mode)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! reason-mode
  :defer t
  :config
  (set-formatter! 'refmt '("refmt") :modes '(reason-mode))
  (add-hook 'reason-mode-hook #'merlin-mode))
#+end_src

** F# / F Sharp

Not using this anymore, so leaving it untangled.

#+begin_src emacs-lisp :tangle no
(use-package! fsharp-mode-structure
  :config
  (setq-default fsharp-indent-offset 4))

(use-package! lsp-mode
  :defer t
  :config
  (setq lsp-fsharp-external-autocomplete t))
#+end_src

** Julia

Not using this for now, so leaving it untangled.

#+begin_src emacs-lisp :tangle no
(use-package! lsp-julia
  :config
  ;; (setq lsp-julia-flags '("--startup-file=no" "--history-file=no"))
  (setq lsp-julia-package-dir nil))

(after! julia-mode
  (add-hook 'julia-mode-hook #'rainbow-delimiters-mode-enable))
#+end_src

** Scala

#+begin_src emacs-lisp :tangle no
;; scala v3 syntax not supported
(add-hook 'scala-mode-hook (lambda ()
                             (setq indent-line-function 'indent-relative-maybe)))
#+end_src

** SQL

#+begin_src emacs-lisp :tangle yes
(setq sql-connection-alist
      '((mydb-prod
         (sql-product 'mysql)
         (sql-server (password-store-get "sql/mydb/prod-host"))
         (sql-user (password-store-get "sql/mydb/prod-user"))
         (sql-password (password-store-get "sql/mydb/prod-password"))
         (sql-database (password-store-get "sql/mydb/prod-db"))
         (sql-port 3306)
         (sql-default-directory "/ssh:mydb:"))))

(defun connect-to-database (label)
  "Connect to the database associated with the given `label`."
  (interactive)
  (let ((product (car (cdr (assoc label sql-connection-alist)))))
    (setq sql-product product)
    (sql-connect label)))

(defun mysql-mydb-prod ()
  (interactive)
  (connect-to-database 'mydb-prod))
#+end_src

** Haskell

#+begin_src emacs-lisp :tangle yes
(after! lsp-haskell
  (setq lsp-haskell-formatting-provider "ormolu"))
#+end_src

** Swift

#+begin_src emacs-lisp :tangle yes
(when (modulep! +tree-sitter)
  (set-tree-sitter! 'swift-mode 'swift-ts-mode
    '((swift :url "https://github.com/alex-pinkus/tree-sitter-swift"))))

;; ---------------------------------------------------------------------------
;; Everything below makes swift-ts-mode get the same toys as swift-mode
;; ---------------------------------------------------------------------------

;; SourceKit-LSP / Eglot (or lsp-mode) ---------------------------------------
(set-eglot-client! '(swift-mode swift-ts-mode) '("sourcekit-lsp"))
(add-hook! '(swift-mode-local-vars-hook swift-ts-mode-local-vars-hook)
           #'lsp! 'append)

;; Company completion --------------------------------------------------------
(when (modulep! :completion company)
  (set-company-backend!
    '(swift-mode swift-ts-mode)
    '(company-sourcekit company-yasnippet)))

;; Flycheck ------------------------------------------------------------------
(when (and (modulep! :checkers syntax) (not (modulep! +lsp)))
  (add-hook! '(swift-mode-hook swift-ts-mode-hook) #'flycheck-mode))

;; Formatter -----------------------------------------------------------------
(set-formatter! 'swiftformat '("swiftformat" "--output" "stdout")
                :modes '(swift-mode swift-ts-mode))
#+end_src

** Nim

#+begin_src emacs-lisp :tangle yes
(after! nim-mode
  (setq lsp-nim-langserver "nimlangserver")
  (add-hook 'nim-mode-local-vars-hook #'lsp!))

(after! apheleia
  ;; Define a formatter that edits files in-place
  (setf (alist-get 'nimpretty apheleia-formatters)
        '("nimpretty"
          "--indent:2"
          "--maxLineLen:100"
          inplace))

  ;; Tell Apheleia to use nimpretty for nim-mode
  (setf (alist-get 'nim-mode apheleia-mode-alist)
        '(nimpretty)))
#+end_src

** AWS CLI

Configurations & keybinds for interacting with AWS CLI.

#+begin_src elisp :tangle yes
(autoload 'aws-ssm-start-session "aws-ssm"
  "Start an AWS SSM session from authinfo." t)

(map! :leader
      (:prefix-map ("j" . "jecs")
       (:prefix-map ("a" . "aws")
        :desc "SSM Start" "s" #'aws-ssm-start-session)))
#+end_src

** Lua

#+begin_src elisp :tangle yes
;; (after! lsp-mode
;;   ;; Force lsp-mode to use the brew-installed lua-language-server
;;   (setq lsp-clients-lua-language-server-bin
;;         (or (executable-find "lua-language-server")
;;             "/opt/homebrew/bin/lua-language-server")))
#+end_src

* Windows NT

Some configuration for when I have to use windows.

#+begin_src emacs-lisp :results none
(when (eq system-type 'windows-nt)
  (progn
    ;; use vs code font
    (set-frame-font "Cascadia Code 12" nil t)

    ;; vterm doesnt work on windows. use eshell instead in packages.el!
    (use-package window
      :custom
      (display-buffer-alist
       ;; bottom slot -1
       '(("\\*doom:eshell-popup:.*\\*"
          (display-buffer-in-side-window)
          (window-height . 0.25)
          (side . bottom)
          (slot . -1)
          (window-parameters . ((no-delete-other-windows . t)))))))))
#+end_src

* MacOS

** X Widgets

#+begin_src emacs-lisp :tangle yes
(when (eq system-type 'darwin)
  (defun jecs/open-raycast ()
    "Open Raycast via AppleScript"
    (interactive)
    (shell-command "open /Applications/Raycast.app"))
  (map! :desc "Open Raycast" :g "C-M-x" #'jecs/open-raycast))
#+end_src

* Other Packages

Additional packages that don't require any configurations.

#+begin_src emacs-lisp :results none :tangle packages.el
(package! lorem-ipsum) ;; fill paragraphs with lorem ipsum
#+end_src
